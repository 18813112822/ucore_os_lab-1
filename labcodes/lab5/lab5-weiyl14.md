# lab5 实验报告

## 练习0：填写已有实验

继续沿用之前的做法，用git diff结合Linux自带的patch命令来完成。 

	git diff <...> --relative=labcodes/lab4 | patch -d labcodes/lab5 -p1

注意到这里我们看上去仅重复了lab4当中的更改，但实际上因为lab3已经包含了更早的lab当中引入的修改，因此只需要这样做其实就已经把所有修改一起应用进来了。

## 练习1: 加载应用程序并执行（需要编码）

do_execv函数调用load_icode（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。

**请在实验报告中简要说明你的设计实现过程。**

整个工作很繁琐，但是要填的部分很显然，遵照说明来做即可。

**请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。**

通过单步跟踪，可以发现ucore选择一个用户程序进行执行之后，经过`proc_run()`到`switch_to()`，将其context的内容加载到寄存器里，压入eip然后ret。`copy_thread()`当中把产生的进程的`context->eip`置为`forkret`，因此执行ret就会导致控制流来到`forkret()`函数，接着调用`forkrets`，把在trapframe当中存储的各项信息载入，最后调用iret，跳转到程序的第一条指令处开始执行。

## 练习2: 父进程复制自己的内存空间给子进程（需要编码）

创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。

**请在实验报告中简要说明如何设计实现”Copy on Write 机制“，给出概要设计，鼓励给出详细设计。**

考虑利用PTE当中权限控制和vma_struct当中权限控制的分隔开的特性来完成这一机制。当一个内存页因COW机制而暂时共享，它就不应当在操作系统不知情的情况下被修改，因此PTE当中写权限应当关闭，转而用vma当中的写权限表明实际的写权限。暂时共享了内存页的进程，其中任何一个试图修改该内存页的内容，都会触发page fault，操作系统介入进行处理，此时就可以根据vma当中的权限判断这是否是COW机制造成的情况，如果是，则进行内存拷贝然后更新页表。

但是这里有一个问题，如果我们限定只有至多两个进程之间使用COW机制，那么在其中任何一个进程试图修改，得到了自己的一份拷贝后，另一个进程的PTE就可以恢复正常，即，变为可写的了。但实际情况是，这个机制应当允许多于两个进程同时共享一个内存页，此时我们需要额外维护一个内存页因COW机制而被引用的次数（这显然区别于通常意义上被引用的次数）。有了这个以后就基本没有什么问题了。

## 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）

**请在实验报告中简要说明你对 fork/exec/wait/exit函数的分析。**

`fork`完成了复制进程所持有的各项资源的操作，并对涉及到的两个进程的返回值作了分开设置。

`exec`将当前进程所持有的资源先释放，然后载入一个ELF可执行文件，分配资源，为其执行创造条件。

`wait`等待子进程退出，获得其返回值然后回收其资源。

`exit`被进程调用时，回收其持有的内存等资源，保存其返回值，并且唤醒其父进程（如果在处于WT_CHILD状态）。

**请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？**

`fork`产生了新的可执行的进程。

`exec`同样产生了新的可执行的进程。

`wait`将当前进程变为等待状态。

`exit`将当前进程变为假死状态。

**请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）**

这在`proc.c`当中已经给出了：

	  alloc_proc                                 RUNNING
	      +                                   +--<----<--+
	      +                                   + proc_run +
	      V                                   +-->---->--+ 
	PROC_UNINIT -- proc_init/wakeup_proc --> PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --> PROC_SLEEPING --
	                                           A      +                                                           +
	                                           |      +--- do_exit --> PROC_ZOMBIE                                +
	                                           +                                                                  + 
	                                           -----------------------wakeup_proc----------------------------------
