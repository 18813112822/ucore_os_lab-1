# lab3 实验报告

## 练习0：填写已有实验

继续沿用之前的做法，用git diff结合Linux自带的patch命令来完成。 

	git diff <...> --relative=labcodes/lab2 | patch -d labcodes/lab3 -p1

注意到这里我们看上去仅重复了lab2当中的更改，但实际上因为lab2已经包含了lab1引入的修改，因此只需要这样做其实就已经把lab1和lab2的修改一起应用进来了。

## 练习1：给未被映射的地址映射上物理页（需要编程）

**请在实验报告中简要说明你的设计实现过程。**

要补全的是`do_pgfault()`函数当中非常小的一部分。通过观察已有的代码，发现`addr`变量当中存有需要被映射的页的起始线性地址（由传入的`addr`参数做`ROUNDDOWN`得到），`perm`变量当中是需要创建的页表项的权限控制位。因此我们首先用`get_pte()`获取PTE（参数`create`置为1，使得该PTE不存在时被自动创建），当PTE为0（表明这不是一个被换出的页），调用`pgdir_alloc_page()`函数申请一个物理页并建立映射关系。

**请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。**

这个题目我想我已经在OpenEdx上面答过了，因此这里只作简单回答。一些关键的位包括Access位，Dirty位。前者可以帮助决定换出页面，后者也可以，但更重要的是决定是否在换出时写回外部存储设备。

**如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？**

缺页服务例程当中缺页会发生的流程应当和其他内核代码执行时发生缺页的处理流程是一样的。和其他异常发生时一样，硬件将错误码和中断号压入栈中（同在ring0，不产生栈的变化）；不同的是，硬件还会将触发这一异常的线性地址写入寄存器CR2。

## 练习2：补充完成基于FIFO的页面替换算法（需要编程）

**请在实验报告中简要说明你的设计实现过程。**

首先需要继续补全练习1涉及到的`do_pgfault()`函数。当调用`get_pte()`得到的PTE非0，我们认为这是一个被换出了的页。遵照注释，首先检查页置换算法是否可用（`swap_init_ok`），然后调用`swap_in()`函数换入这个页。`swap_in()`函数会传递回一个指向`Page`结构的指针`page`，其对应的物理页存有被换入的内容，我们将`addr`赋给`page->vaddr`，并用`page_insert()`对页表进行修改，调用`swap_map_swappable()`让页置换算法知道这个页的存在，就完成了处理。

在FIFO页面替换算法当中，需要补全的有两个函数。一是`_fifo_map_swappable()`，这比较简单，由于链表当中的页按来到的顺序从前至后，因此只需要把新的页插入到队尾；又因为提供的链表实现是环状，队尾即是`head`的前面，因此用`list_add_before()`就能完成。二是`_fifo_swap_out_victim()`，这同样不难，用`list_next(head)`得到队首，从链表中删除它，最后把利用`le2page()`宏得到的`Page`结构指针赋给`*ptr_page`就可以了。

**如果要在ucore上实现"extended clock页替换算法"请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。**

目前的框架是支持的。设计方案已经作为课堂思考题在piazza上回答过了。extended clock和FIFO不同的地方主要在于swap_out_victim函数需要实现不同的算法逻辑，同时需要利用PTE当中存储的该页是否被访问过的信息（这需要利用page->pra_vaddr去找到PTE）。而链表本身就是环状的，因此在链表的维护和访问上并不需要太大的改动。